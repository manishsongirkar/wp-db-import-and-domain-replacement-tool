#!/usr/bin/env bash

# ================================================================
# WordPress Database Import & Domain Replacement Tool
# Global Command Wrapper
# ================================================================
#
# Description:
#   This script acts as the global command-line wrapper for the entire WordPress
#   Database Import Tool. It resolves the executable's path, loads the main
#   script (`import_wp_db.sh`), and directs command-line arguments to the correct
#   internal functions (e.g., `show-links`, `update`, `import_wp_db`). It allows
#   the tool to be executed globally after symbolic linking.
#
# Version: See VERSION file
#
# Usage:
#   wp-db-import                    # Run the main import function
#   wp-db-import config-show        # Show unified configuration status
#   wp-db-import config-create      # Create configuration with site mappings
#   wp-db-import config-validate    # Validate configuration structure
#   wp-db-import config-edit        # Open configuration in editor
#   wp-db-import show-links         # Show local site links
#   wp-db-import setup-proxy        # Auto-setup Stage File Proxy (uses config)
#   wp-db-import show-cleanup       # Show revision cleanup commands
#   wp-db-import update             # Update to latest version
#   wp-db-import version            # Show version and git info
#   wp-db-import test               # Run test suite to validate tool functionality
#   wp-db-import --help             # Show this help message
#
# Installation:
#   Run: ./install.sh
#   This creates a symlink to make 'wp-db-import' available globally
#
# Auto-Updates:
#   Since installation uses symlinks, running 'git pull' in the repo
#   directory automatically makes updates available globally.
#
# ================================================================

# Get the directory where this script is located
# Handle both direct execution and symlinked installation
SCRIPT_PATH="${BASH_SOURCE[0]}"
# If it's a symlink, resolve to the actual file
if [[ -L "$SCRIPT_PATH" ]]; then
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
MAIN_SCRIPT="$SCRIPT_DIR/import_wp_db.sh"

# Color definitions for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# ===============================================
# Function to show help
# ===============================================
#
# Description: Displays the full list of available `wp-db-import` commands,
#              along with information about updates and usage tips.
#
# Parameters:
#   - None.
#
# Returns:
#   - Prints the formatted help message to stdout.
#
show_help() {
    printf "${CYAN}${BOLD}WordPress Database Import & Domain Replacement Tool${RESET}\n"
    printf "================================================================\n\n"
    printf "${BOLD}USAGE:${RESET}\n"
    printf "  wp-db-import                    Run the main import function\n"
    printf "  wp-db-import config-show        Show unified configuration status\n"
    printf "  wp-db-import config-create      Create configuration with site mappings\n"
    printf "  wp-db-import config-validate    Validate configuration structure\n"
    printf "  wp-db-import config-edit        Open configuration in editor\n"
    printf "  wp-db-import show-links         Show local site links\n"
    printf "  wp-db-import setup-proxy        Auto-setup Stage File Proxy (uses config)\n"
    printf "  wp-db-import show-cleanup       Show revision cleanup commands\n"
    printf "  wp-db-import update             Update to latest version\n"
    printf "  wp-db-import version            Show version and git info\n"
    printf "  wp-db-import test               Run test suite to validate tool functionality\n"
    printf "  wp-db-import --help             Show this help message\n\n"

    printf "${BOLD}UPDATES:${RESET}\n"
    printf "  Since installation uses symlinks, running 'git pull' in the\n"
    printf "  repository directory automatically updates the global command.\n"
    printf "  Or use: wp-db-import update (does git pull automatically)\n\n"

    printf "${YELLOW}üí° TIP:${RESET} Place your SQL file in the WordPress root directory before running.\n"
}

# ===============================================
# Function to check if we're in a WordPress directory
# ===============================================
#
# Description: Checks the current directory and its ancestors for a `wp-config.php`
#              file to confirm the user is executing the command within a WordPress installation.
#
# Parameters:
#   - None.
#
# Returns:
#   - 0 (Success) if `wp-config.php` is found.
#   - 1 (Failure) otherwise, printing an error message.
#
check_wordpress_directory() {
    local current_dir="$(pwd)"
    local wp_root="$current_dir"

    # Search for wp-config.php up the directory tree
    while [[ "$wp_root" != "/" && ! -f "$wp_root/wp-config.php" ]]; do
        wp_root=$(dirname "$wp_root")
    done

    if [[ ! -f "$wp_root/wp-config.php" ]]; then
        printf "${RED}‚ùå Error: Not in a WordPress directory${RESET}\n"
        printf "${YELLOW}üí° Please navigate to a WordPress installation directory first${RESET}\n"
        printf "   Example: cd ~/Local\\ Sites/mysite/app/public\n"
        return 1
    fi

    printf "${GREEN}‚úÖ WordPress installation found: ${wp_root}${RESET}\n"
    return 0
}

# ===============================================
# Function to load the main script and modules
# ===============================================
#
# Description: Sources the core `import_wp_db.sh` file, which in turn loads the
#              entire modular system, making all required functions globally available.
#
# Parameters:
#   - None.
#
# Returns:
#   - 0 (Success) if the main script and modules load.
#   - 1 (Failure) otherwise.
#
load_main_script() {
    if [[ ! -f "$MAIN_SCRIPT" ]]; then
        printf "${RED}‚ùå Error: Main script not found at: $MAIN_SCRIPT${RESET}\n"
        printf "${YELLOW}üí° Please ensure you're running from the correct directory${RESET}\n"
        return 1
    fi

    # Source the main script (this loads all modules automatically)
    if ! source "$MAIN_SCRIPT" >/dev/null 2>&1; then
        printf "${RED}‚ùå Error: Failed to load main script${RESET}\n"
        printf "   Check: $MAIN_SCRIPT\n"
        return 1
    fi

    return 0
}

# ===============================================
# Function to get the current version
# ===============================================
#
# Description: Reads the project version string from the `VERSION` file.
#
# Parameters:
#   - None.
#
# Returns:
#   - The version string (echoed) or "unknown" on failure.
#
get_version() {
    local version="unknown"
    if [[ -f "$SCRIPT_DIR/VERSION" ]]; then
        version=$(cat "$SCRIPT_DIR/VERSION" 2>/dev/null | tr -d '\n\r' | head -1)
        # Fallback if VERSION file is empty or unreadable
        if [[ -z "$version" ]]; then
            version="unknown"
        fi
    fi
    echo "$version"
}

# ===============================================
# Function to show version information
# ===============================================
#
# Description: Displays the current tool version, associated Git repository
#              information (branch, commit, updates available), and installation status.
#
# Parameters:
#   - None.
#
# Returns:
#   - Prints formatted version and status information to stdout.
#
show_version() {
    local version=$(get_version)

    printf "${CYAN}${BOLD}WordPress Database Import Tool${RESET}\n"
    printf "Version: ${GREEN}${version}${RESET}\n\n"

    # Show git information if we're in a git repository
    if git -C "$SCRIPT_DIR" rev-parse --git-dir >/dev/null 2>&1; then
        printf "${BOLD}Git Information:${RESET}\n"
        local current_commit=$(git -C "$SCRIPT_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local current_branch=$(git -C "$SCRIPT_DIR" branch --show-current 2>/dev/null || echo "unknown")
        local repo_url=$(git -C "$SCRIPT_DIR" remote get-url origin 2>/dev/null || echo "unknown")

        printf "  Branch: ${YELLOW}${current_branch}${RESET}\n"
        printf "  Commit: ${YELLOW}${current_commit}${RESET}\n"
        printf "  Repository: ${CYAN}${repo_url}${RESET}\n\n"

        # Check if there are uncommitted changes
        if ! git -C "$SCRIPT_DIR" diff-index --quiet HEAD -- >/dev/null 2>&1; then
            printf "${YELLOW}‚ö†Ô∏è  Note: You have uncommitted changes in the repository${RESET}\n"
        fi

        # Check if local is behind remote
        if git -C "$SCRIPT_DIR" fetch >/dev/null 2>&1; then
            local behind_count=$(git -C "$SCRIPT_DIR" rev-list HEAD..origin/"${current_branch}" --count 2>/dev/null || echo "0")
            if [[ "$behind_count" -gt 0 ]]; then
                printf "${YELLOW}‚û§ ${behind_count} update(s) available. Run: wp-db-import update${RESET}\n"
            fi
        fi
    else
        printf "${YELLOW}üí° Not a git installation (downloaded as archive?)${RESET}\n"
    fi

    printf "\n${BOLD}Installation:${RESET}\n"
    if [[ -L "${BASH_SOURCE[0]}" ]]; then
        local link_target=$(readlink "${BASH_SOURCE[0]}")
        printf "  Installed as symlink: ${GREEN}‚úÖ${RESET}\n"
        printf "  Symlink: ${BASH_SOURCE[0]}\n"
        printf "  Target: ${link_target}\n"

        # Check if it's a git repository for auto-updates
        if git -C "$SCRIPT_DIR" rev-parse --git-dir >/dev/null 2>&1; then
            printf "  Auto-updates: ${GREEN}Available (git repository)${RESET}\n"
        else
            printf "  Auto-updates: ${YELLOW}Limited (not a git repository)${RESET}\n"
        fi
    else
        printf "  Running directly from: ${BASH_SOURCE[0]}\n"
        if git -C "$SCRIPT_DIR" rev-parse --git-dir >/dev/null 2>&1; then
            printf "  Auto-updates: ${GREEN}Available (git repository)${RESET}\n"
            printf "  ${CYAN}üí° Tip: Run ./install.sh to make this command globally available${RESET}\n"
        else
            printf "  Auto-updates: ${YELLOW}Not available (downloaded as archive)${RESET}\n"
            printf "  ${CYAN}üí° Tip: Clone from git repository for auto-updates${RESET}\n"
        fi
    fi
}

# ===============================================
# Function to update the tool to latest version
# ===============================================
#
# Description: Performs a `git pull` operation within the tool's installation directory
#              to fetch and apply the latest changes from the remote repository.
#
# Parameters:
#   - None.
#
# Returns:
#   - 0 (Success) if the tool is successfully updated or already up-to-date.
#   - 1 (Failure) if the installation is not a Git repository or the update fails.
#
# Behavior:
#   - Checks for uncommitted local changes and prompts the user before proceeding.
#   - Uses `git -C "$SCRIPT_DIR" pull` to perform the update.
#
update_tool() {
    printf "${CYAN}üîÑ Updating WordPress Database Import Tool...${RESET}\n\n"

    # Check if we're in a git repository
    if ! git -C "$SCRIPT_DIR" rev-parse --git-dir >/dev/null 2>&1; then
        printf "${RED}‚ùå Error: Not in a git repository${RESET}\n"
        printf "\n${YELLOW}This tool was likely downloaded as a ZIP archive.${RESET}\n"
        printf "${CYAN}To enable auto-updates, please:${RESET}\n"
        printf "  1. Clone the repository instead:\n"
        printf "     ${BOLD}git clone https://github.com/manishsongirkar/wp-db-import-and-domain-replacement-tool.git${RESET}\n"
        printf "  2. Run the installer from the cloned repository:\n"
        printf "     ${BOLD}cd wp-db-import-and-domain-replacement-tool && ./install.sh${RESET}\n"
        printf "\n${YELLOW}For manual updates:${RESET}\n"
        printf "  1. Download the latest release from GitHub\n"
        printf "  2. Extract and replace your current installation\n"
        printf "  3. Run ./install.sh again if needed\n"
        return 1
    fi

    # Show current status
    local current_commit=$(git -C "$SCRIPT_DIR" rev-parse --short HEAD 2>/dev/null)
    local current_branch=$(git -C "$SCRIPT_DIR" branch --show-current 2>/dev/null)
    printf "Current: ${YELLOW}${current_branch}@${current_commit}${RESET}\n"

    # Check for uncommitted changes
    if ! git -C "$SCRIPT_DIR" diff-index --quiet HEAD -- >/dev/null 2>&1; then
        printf "${YELLOW}‚ö†Ô∏è  Warning: You have uncommitted changes${RESET}\n"
        printf "Do you want to continue? This may overwrite local changes (y/N): "
        read -r confirm_update
        if [[ "$confirm_update" != [Yy]* ]]; then
            printf "${YELLOW}Update cancelled${RESET}\n"
            return 0
        fi
    fi

    # Perform git pull
    printf "\n${CYAN}üì• Fetching latest changes...${RESET}\n"
    if git -C "$SCRIPT_DIR" pull origin "${current_branch:-main}" 2>&1; then
        local new_commit=$(git -C "$SCRIPT_DIR" rev-parse --short HEAD 2>/dev/null)
        if [[ "$current_commit" != "$new_commit" ]]; then
            printf "\n${GREEN}‚úÖ Successfully updated!${RESET}\n"
            printf "Updated: ${YELLOW}${current_branch}@${current_commit}${RESET} ‚Üí ${GREEN}${current_branch}@${new_commit}${RESET}\n"
            printf "\n${CYAN}üí° Changes are immediately available since you're using a symlinked installation${RESET}\n"
        else
            printf "\n${GREEN}‚úÖ Already up to date${RESET}\n"
        fi
    else
        printf "\n${RED}‚ùå Update failed${RESET}\n"
        printf "${YELLOW}üí° Try running: cd $SCRIPT_DIR && git pull${RESET}\n"
        return 1
    fi
}

# Parse command line arguments
case "${1:-}" in
    --help|-h|help)
        show_help
        exit 0
        ;;
    version|-v|--version)
        show_version
        exit 0
        ;;
    update|--update)
        update_tool
        exit $?
        ;;
    show-links)
        printf "${CYAN}üîó Displaying local site links...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        show_local_site_links
        ;;
    show-cleanup)
        printf "${CYAN}üóëÔ∏è Generating revision cleanup commands...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        # Pass any additional arguments (like 'multisite', 'test', etc.)
        shift # Remove 'show-cleanup' from arguments
        show_revision_cleanup_commands "$@"
        ;;
    setup-proxy)
        printf "${CYAN}üì∏ Setting up stage file proxy...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi

        # Get config file path for unified setup
        config_path=""
        if command -v get_config_file_path >/dev/null 2>&1; then
            config_path=$(get_config_file_path)
        elif command -v get_wpdb_config_path >/dev/null 2>&1; then
            config_path=$(get_wpdb_config_path)
        else
            config_path="wpdb-import.conf"
        fi

        # Use unified setup if available, otherwise fallback to legacy
        if command -v setup_stage_file_proxy_unified >/dev/null 2>&1; then
            setup_stage_file_proxy_unified "$config_path"
        else
            setup_stage_file_proxy
        fi
        ;;
    detect)
        printf "${CYAN}üîç Detecting WordPress installation type...${RESET}\n\n"

        # Load main script to get detection function
        if ! load_main_script; then
            exit 1
        fi

        # Ensure detection function is loaded
        if ! declare -f detect_wordpress_installation_type >/dev/null; then
            detection_module="$SCRIPT_DIR/lib/core/wp_detection.sh"
            if [[ -f "$detection_module" ]]; then
                source "$detection_module" || {
                    printf "${RED}‚ùå Error: Failed to load detection module${RESET}\n"
                    exit 1
                }
            else
                printf "${RED}‚ùå Error: Detection module not found at: $detection_module${RESET}\n"
                exit 1
            fi
        fi

        # Parse arguments for detect command
        verbose="false"
        detection_dir=""
        shift
        while [[ $# -gt 0 ]]; do
            case $1 in
                --verbose|-v)
                    verbose="true"
                    ;;
                --quiet|-q|--quite)
                    verbose="false"
                    ;;
                *)
                    if [[ "$1" != -* ]]; then
                        detection_dir="$1"
                    fi
                    ;;
            esac
            shift
        done
        detection_dir="${detection_dir:-$(pwd)}"

        result=$(detect_wordpress_installation_type "$detection_dir" "$verbose")

        IFS='|' read -r inst_type ms_type net_flag blog_count site_count method <<< "$result"

        printf "${GREEN}‚úÖ WordPress root found: %s${RESET}\n\n" "$detection_dir"

        printf "${BOLD}üéØ WordPress Site Details:${RESET}\n"
        printf "============================\n"
        if [[ "$inst_type" == "multisite" ]]; then
            printf "WordPress Site Type: ${GREEN}multisite${RESET}\n"
            printf "Multisite Configuration: ${YELLOW}%s${RESET}\n" "$ms_type"
            printf "WP-CLI Network Flag: ${CYAN}%s${RESET}\n" "$net_flag"
            printf "Multisite Blog Count: %s\n" "$blog_count"
            printf "Main Site Count: %s\n" "$site_count"
            printf "Detection Method: %s\n" "$method"
        elif [[ "$inst_type" == "single" ]]; then
            printf "WordPress Site Type: ${GREEN}single${RESET}\n"
            printf "Main Site Count: %s\n" "$site_count"
            printf "Detection Method: %s\n" "$method"
        else
            # Fallback for single site detected by other methods
            printf "WordPress Site Type: ${GREEN}single${RESET}\n"
            printf "Main Site Count: %s\n" "$site_count"
            printf "Detection Method: %s\n" "$method"
        fi

        printf "\n${GREEN}‚úÖ Detection completed using method: %s${RESET}\n" "$method"
        ;;
    config-show)
        printf "${CYAN}üìã Showing configuration...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        # Show configuration
        config_path=""
        if config_path=$(get_config_file_path); then
            show_config "$config_path"
        else
            printf "${RED}‚ùå Could not determine config file path${RESET}\n"
            exit 1
        fi
        ;;
    config-create)
        printf "${CYAN}üìù Creating new configuration...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        # Create configuration
        config_path=""
        wp_root=""
        if config_path=$(get_config_file_path) && wp_root=$(find_wp_root); then
            prompt_and_save_config "$config_path" "$wp_root"
        else
            printf "${RED}‚ùå Could not determine config file path${RESET}\n"
            exit 1
        fi
        ;;
    config-validate)
        printf "${CYAN}‚úÖ Validating configuration...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        # Validate configuration
        config_path=""
        if config_path=$(get_config_file_path); then
            validate_config_file "$config_path"
        else
            printf "${RED}‚ùå Could not determine config file path${RESET}\n"
            exit 1
        fi
        ;;
    config-edit)
        printf "${CYAN}‚úèÔ∏è Opening configuration for editing...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        # Edit configuration
        config_path=""
        if config_path=$(get_config_file_path); then
            if [[ -f "$config_path" ]]; then
                # Try to use user's preferred editor
                editor="${EDITOR:-nano}"
                if command -v "$editor" >/dev/null 2>&1; then
                    "$editor" "$config_path"
                    printf "${GREEN}‚úÖ Configuration file edited${RESET}\n"
                    printf "Run 'wp-db-import config-validate' to check the configuration\n"
                else
                    printf "${RED}‚ùå Editor not found: $editor${RESET}\n"
                    printf "Set EDITOR environment variable or use: nano, vim, code, etc.\n"
                    exit 1
                fi
            else
                printf "${YELLOW}üìù Config file not found. Creating new one...${RESET}\n"
                wp_root=""
                if wp_root=$(find_wp_root); then
                    prompt_and_save_config "$config_path" "$wp_root"
                else
                    printf "${RED}‚ùå Could not find WordPress root${RESET}\n"
                    exit 1
                fi
            fi
        else
            printf "${RED}‚ùå Could not determine config file path${RESET}\n"
            exit 1
        fi
        ;;
    test)
        # Public command to run test suite - can be executed from any directory
        # printf "${CYAN}üß™ Running WordPress Database Import Tool Test Suite${RESET}\n\n"

        # Shift to remove 'test' from arguments
        shift

        # Change to the script directory to run tests
        original_dir="$(pwd)"
        cd "$SCRIPT_DIR"

        # Check if test runner exists
        if [[ ! -f "run_tests.sh" ]]; then
            printf "${RED}‚ùå Test runner not found: run_tests.sh${RESET}\n"
            printf "${YELLOW}üí° Ensure you have the complete tool installation${RESET}\n"
            cd "$original_dir"
            exit 1
        fi

        # Make test runner executable if needed
        chmod +x run_tests.sh

        # Run tests with passed arguments (default to all tests if no args)
        test_args="${*}"
        if [[ -z "$test_args" ]]; then
            test_args="all"
        fi

        # printf "${DIM}Running from: $SCRIPT_DIR${RESET}\n"
        # printf "${DIM}Arguments: $test_args${RESET}\n\n"

        # Execute the test runner
        if ./run_tests.sh $test_args; then
            printf "\n${GREEN}‚úÖ Test suite completed successfully${RESET}\n"
            exit_code=0
        else
            printf "\n${RED}‚ùå Test suite completed with failures${RESET}\n"
            exit_code=1
        fi

        # Return to original directory
        cd "$original_dir"
        exit $exit_code
        ;;
    validate)
        # Private command for testing - validate tool functionality
        # This command is not shown in help and is used for automated testing
        if ! load_main_script; then
            exit 1
        fi
        # Run validation tests
        if command -v validate_tool_functionality >/dev/null 2>&1; then
            validate_tool_functionality "$@"
        else
            printf "${RED}‚ùå Validation function not available${RESET}\n"
            exit 1
        fi
        ;;
    "")
        # No arguments - run the main import function
        printf "${CYAN}üöÄ Starting WordPress database import...${RESET}\n\n"
        if ! check_wordpress_directory; then
            exit 1
        fi
        if ! load_main_script; then
            exit 1
        fi
        import_wp_db
        ;;
    *)
        printf "${RED}‚ùå Unknown command: ${1}${RESET}\n\n"
        show_help
        exit 1
        ;;
esac
